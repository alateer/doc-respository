## 计算机操作系统

https://www.cnblogs.com/cxuanBlog/p/13297199.html

### 概述

+ 操作系统（Operating System 简称OS）是管理计算机硬件和软件资源的程序，是计算机系统的内核和基石

+ 操作系统本质上是运行在计算机上的软件程序
+ 操作系统为用户提供了一个与系统交互的操作界面
+ 操作系统分为内核和外壳（内核是能操是围绕内核的应用程序）

> 内核负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性 
>
> 是连接应用程序和硬件的桥梁

### 简单分类

1. windows：目前最流行的个人桌面操作系统
2. Unix：最早的多用户、多任务操作系统，属于分时操作系统。Unix大多用于服务器、工作站。
3. Linux：是一套免费使用和自由传播的类Unix操作系统

### 什么是系统调用

对于用户态和系统态：

根据进程访问资源的特点，可以根据进程在系统上的运行级别：

+ 用户态（user mode）：用户态运行的进程可以直接读取用户程序的数据
+ 系统态（kernel mode）：系统态运行的进程或程序可以访问计算机的任何资源，不受限制

我们运行的程序基本都是运行在用户态

系统调用：

就是说，在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理，进程管理，内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成

系统调用按照功能大致分为：

+ 设备管理。设备的请求、释放和启动等
+ 文件管理。文件的读、写、创建和删除等
+ 进程控制。进程的创建、撤销、阻塞及唤醒等
+ 进程通信。进程间的消息传递或信号传递
+ 内存管理。内存的分配、回收以及获取作业占用内存区大小及地址等

## 进程和线程

### 并发和并行

并发是指**宏观上在一段时间内**能够同时运行多个程序

并行则是指同一时刻能运行多个指令

并行需要硬件支持，如多流水线或者多处理器

操作系统通过引入进程和线程，使得程序能够并发运行

### 进程和线程的区别

+ 进程是资源分配的最小单位，线程是程序执行的最小单位
+ 进程有自己独立的地址空间，线程没有独立的地址空间，它使用相同的地址空间共享资源
+ 进程独立
+ 一个进程可以有多个线程
+ 多个线程可以共享进程的资源
+ 线程开销小，效率高，可频繁切换，但不利于资源的管理和保护，而进程则刚好相反

### 进程有几种状态

一般情况下分为5种

+ 创建状态（new）
+ 就绪状态（ready）
+ 运行状态（running）
+ 阻塞状态（waiting）
+ 结束状态（terminated）

### 进程间的通信方式

大概有7种通信方式

参考文章：https://www.jianshu.com/p/c1015f5ffa74

+ 管道/匿名管道（Pipes）

用于具有亲缘关系的父子进程或兄弟进程之间的通信

+ 有名管道（Names Pipes）

遵循先进先出（FIFO），以磁盘文件的方式存在，可以用于任意两个进程之间的通信

+ 信号（Sign）

用于通知接收进程某个事件已经发生

+ 消息队列（Message Queuing）

是消息的链表，存放在内存中，由消息队列标识符标识

+ 信号量（Semaphores）

信号量是一个计数器，其意图在于进程间的同步，用于多进程对共享数据的访问

+ 共享内存（Shared Memory）

使得多个进程可以访问同一块内存空间

+ 套接字  

用于客户端和服务器之间通过网络进行通信

### 线程间的同步方式

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键资源的使用冲突，同步方式有：

+ 互斥量（Mutex）

采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个进程同时访问。不如 Java 中的 synchronized 关键字和各种 Lock 都是这种机制

+ 信号量（Semaphores）

允许同一时刻多个线程访问同一资源，但需要控制同一时刻访问此资源的最大线程数量

+ 事件（Event）

Wait/Notify 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程的优先级的比较操作

### 进程的调度算法

+ 先到先服务（FCFS）调度算法

​         从就绪队列中选择一个**最先进入该队列的进程**为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

+ 短作业优先（SJF）调度算法

​        从就绪队列中选出一个**估计运行时间最短的进程**为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

+ 时间轮转调度算法

​        时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即**该进程允许运行的时间**。

+ 多级反馈队列调度算法

​        前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能**使高优先级的作业得到响应又能使短作业（进程）迅速完成**。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。

+ 优先级调度

​        为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## 操作系统内存管理基础

### 内存管理介绍

#### 操作系统的内存管理主要是做什么

​	主要负责内存的分配与回收（malloc函数：内存申请，free函数：内存释放），另外就是地址转换，也就是将逻辑地址转换为相应的物理地址的功能也由内存管理来做

### 常见的几种内存管理机制

#### 内存管理机制是什么，有哪些方式

简单的可以分为**连续分配管理方式**和**非连续分配管理方式**两种，连续分配管理方式就是为一个用户程序分配一个连续的内存空间，比如常见的块式管理；而非连续分配管理方式允许一个用户程序使用的内存分布在离散或者说不相邻的内存空间上，常见的如页式管理和段式管理

+ 块式管理

远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只有一个程序，如果某个程序需要内存的话，操作系统就会分配给该进程一块内存，但当这个进程占用内存很小的话，所分配的内存空间就会被浪费掉

+ 页式管理

把主存分为大小相同且固定的一页一页的形式，相较于块式管理所划分的力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址

+ 段式管理

页式管理虽然提高了内存利用率，但是其中的页在实际中并没有任何意义。而段式管理将主存分为一段一段的，而且每一段的空间又比每一页的空间小很多。但最重要的时，段是有实际意义的，每个段定义了一组逻辑信息，如有主程序段MAIN，子程序段X，数据段D，栈段S等。段式管理通过段表对应逻辑地址和物理地址

还有一个最重要的：

+ 段页式管理方式

结合了段式管理和页式管理的优点。将主存先分为一个一个的段，再在段中分为一个一个的页，这样，段与段之间以及段的内部都是离散的

### 快表和多级页表

页表管理机制中有两个很重要的概念，快表和多级页表，两者分别解决了页式管理机制中两个很重要的问题

在分页内存管理中，有两个很重要的点：

+ 虚拟地址（逻辑地址？）到物理地址的转换要快
+ 解决虚拟地址空间大，页表也会很大的问题

![image-20200805143233372](D:/Photo/Typora/image-20200805143233372.png)

### 分页机制和分段机制的异同

#### 相同点：

+ 分段机制和分页机制都是为了提高内存利用率，降低内存碎片
+ 页和段都是离散存储的。但是，每个页和段的内部都是连续的

#### 不同点：

+ 页的大小固定，由操作系统决定；段的大小不固定，取决于当前运行的程序
+ 分页仅仅是为了满足操作系统对内存管理的需求；而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能更好满足用户需求

### 逻辑（虚拟）地址和物理地址

我们编程其实一般都是和逻辑地址打交道的，比如在C语言中指针里面存储的数值就是一个内存中的地址，这个地址就是我们说的逻辑地址，逻辑地址是由操作系统决定的。而物理地址就是真实物理内存的地址，具体来说就是内存地址寄存器中的地址，物理地址是内存中的真正地址

### CPU寻址，虚拟地址空间

现代处理器使用的是一种称为虚拟寻址的寻址方式，使用虚拟寻址时，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理地址，其转换是由内存管理单元（MMU）负责

![image-20200805145108442](D:/Photo/Typora/image-20200805145108442.png)

## 虚拟内存

### 什么是虚拟内存

对于像是windows系统来说，当我们点开很多占用内存空间的应用时，这些所占用的内存可能远远高于我们电脑本身具有的内存空间。可以这样的原因就是因为有虚拟内存的存在，通过虚拟内存可以让程序拥有比实际物理内存空间还大的可用内存空间。

虚拟内存为每个进程提供了一个一致的，私有的地址空间，它让每个进程产生了一种自己在独享内存空间的错觉（每个进程拥有一片连续完整的内存空间），这样可以有效的管理内存并减少出错

虚拟内存是计算机系统内存管理的一种技术，我们可以手动的设置虚拟内存。

虚拟内存的重要意义是它定义了一片连续的虚拟地址空间，并把内存扩展到硬盘空间

> **虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:https://zh.wikipedia.org/wiki/虚拟内存

### 局部性原理

局部性原理是虚拟内存实现的基础，正是程序运行存在局部性原理，才可以只装入部分程序到内存中运行

对于一个程序：在某个较短的时间段内，程序的执行局限于某一小部分，且程序访问的存储空间也局限于某一区域

表现在两个方面：

+ **时间局部性**

某条指令一旦被执行，那么这条指令在不久之后可能会再次被执行；某个数据被访问，则该数据在不久之后可能还会被访问，产生时间局部性的原因，主要是程序中可能存在大量的循环操作

+ **空间局部性**

程序一旦访问了某一区域的存储单元，不久之后，其附近的存储单元也可能被访问，即程序在一定时间内访问的存储区域可能集中在某一区域内，因为指令通常是顺序存放，顺序执行的

​		时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。**虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。**

### 虚拟存储器

​		基于局部性原理，我们可以先将程序的一部分装入内存，其余的部分留在外存，就可以启动程序执行。

​		外存往往要比内存大很多的，所以我们运行的软件的内存大小是可以比计算机系统实际运行的内存大小大的。**当访问的信息不再内存是，由操作系统将所需要的信息调入内存，然后继续执行程序，另一方面，内存中不用的内容被换到外存中，腾出空间放要进入内存的信息。**这样，计算机就好像为用户提供了一个比实际内存大得多的存储器----虚拟存储器

​		实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。

### 虚拟内存的技术实现


### 页面置换算法

#### 页面置换算法的作用？常见的页面置换算法？

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生页面中断（即访问的页不再主存，需要操作系统将其调入主存后再次访问。这样，被内存映射的文件实际上成了一个分页交换文件）

发生页面中断时，如果当前内存中没有空余的页面，操作系统就会在内存中选择一个页面将其移出内存，以便为即将调入的页面腾出空间。

用来淘汰哪一页的规则叫做页面置换算法，可以看作是一种淘汰页面的规则

+ **OPT页面置换算法（最佳页面置换算法）**

该置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。

+ **FIFO页面置换算法（先进先出页面置换算法）**

该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。

+ **LRU页面置换算法（最近最久未使用页面置换算法）**

该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。

+ **LFU页面置换算法（最少使用页面置换算法）**

该置换算法选择在之前时期使用最少的页面作为淘汰页。
