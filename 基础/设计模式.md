## 设计模式（Design Patterns）

​1995年，四个人出版了《设计模式：可复用面向对象软件的基础》一书，其中收录了23种设计模式，直到如今，狭义上的设计模式就是指这23种经典的设计模式

​设计模式是**解决特定问题的一系列套路或者说是模板**，是前辈们的代码设计经验的总结，具有一定的普遍性

​目的是提高:
- 代码的可重用性
- 代码的可读性
- 代码的可靠性

设计模式的本质是面向对象原则的实际应用，是对类的封装，继承和多态以及类的关联关系和组合关系的充分理解

四个关键的元素：模式名称、问题、解决方案、效果

### 分类

#### 根据目的来分类：即用来完成什么工作

创建型模式：用于描述怎样创建对象，主要的特点是“将对象的使用与创建分离”，包括：

​	单例	原型	工厂方法	抽象工厂	建造者

结构型模式：用于描述如何将类和对象通过某种布局组成更大的结构，包括：

​	代理	适配器	桥接	装饰	外观	享元	组合

行为型模式：用于描述类或对象之间如何通过协作完成对单个对象都无法完成的任务，包括：

​	模板方法	策略	命令	职责链	状态	观察者	中介者	迭代器	访问者	备忘录	解释器

#### 根据作用范围来分：即作用在类上还是作用于对象上

类模式：用于处理类和子类之间的关系，关系通过继承建立，静态的，编译时便可确定，包括：

​	工厂模式	适配器	模板方法	解释器

对象模式：处理对象之间的关系，关系通过组合或是聚合实现，动态的，运行时是变化的，包括：

​	除以上四种模式都是

### 功能

​	单例模式（Singleton）：某个类**只能生成一个实例**，该类**提供了一个全局访问点**供外部获取该实例，其拓展是有限单例模式

​	原型模式（Prototype）：**将一个对象作为原型**，通过对其进行**复制**而克隆出多个**和原型类似的**新实例。

​	工厂方法（factory method）模式：定义一个**用于创建产品的接口**，由子类决定生产什么产品

​	抽象工厂（Abstract factory）模式：提供一个**创建产品族的接口**，其每个子类可以生产一系列相关的产品

​	建造者（Builder）模式：将一个**复杂的对象分解成多个相对简单的部分**，然后根据不同需要分别创建它们，最后构造成该复杂对象

​	代理（Proxy）模式：为某对象提供一种代理**以控制对该对象的访问**。即客户端通过代理间接地访问该对象，从而**限制、增强或修改该对象的一些特性**。

​	适配器（Adapter）模式：**将一个类的接口转换成客户希望的另一个接口**，使得原本由于接口不兼容而不能一起工作的那些类能一起工作

​	桥接（Bridge）模式：**将抽象与现实分离**，使他们可以**独立变化**。它是**用组合关系代替继承关系**来实现，从而降低了抽象和实现这两个可变维度的耦合度。

​	装饰（Decorator）模式：动态的给对象增加一些职位，即增加其额外的功能。

​	外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使得这些子系统更加容易被访问

​	享元（Flyweight）模式：运用**共享技术**来有效的支持大量**细粒度对象的复用**

​	组合（Composite）模式：**将对象组合成树状层次结构**，使用户对单个对象的组合对象具有一致大的访问性。

​	模板方法（Template Method）模式：定义一个**操作中的算法骨架**，而将算法的一些步骤**延迟到子类中**，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤

​	策略（Strategy）模式：定义了一系列的算法，并将每个算法封装起来，使他们可以相互交替，并且算法的改变不会影响到使用算法的用户

​	命令（Command）模式：将一个请求封装为一个对象，使得发**出请求的责任**和**执行请求的责任**分割开。

​	职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。

​	状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。

​	观察者（Observer）模式：多个对象间**存在一对多的关系**，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

​	中介者（Mediator）模式：定义一个**中介对象**来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解

​	迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表达。

​	访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素都有多个访问者对象访问

​	备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。

​	解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器



### UML中的类图及类图之间的关系

UML（Unified Modeling Language）：统一建模语言

是用来设计软件蓝图的可视化建模语言，是面向对象的建模语言的国际标准

特点是简单，统一，图形化，能表达软件中的动态与静态信息

#### 组件

类

+ 类名
+ 属性
+ 操作

接口

类图

#### 类之间的关系

+ 依赖关系
+ 关联关系
  + 一般关联关系
  + 聚合关系
  + 组合关系

+ 泛化关系
+ 实现关系

### 面向对象7个设计原则

#### 开闭原则

定义：**软件实体应当对扩展开放，对修改关闭**

软件实体：

+ 项目中划分出来的模块
+ 类与接口
+ 方法

作用：

+ 方便测试
+ 提高代码复用性
+ 提高软件可维护性

实现方式：

+ 抽象约束，封装变化

#### 里氏替换原则

定义：**继承必须确保超类所拥有的性质在子类中仍然成立**

作用：

+ 是实现开闭原则的重要方式之一
+ 克服了继承中重写父类造成的可复用性变差的缺点
+ 动作正确性的保证

实现方式：

+ 子类可以扩展父类的功能，但不能改变父类原有的功能
+ 即尽量不要重写父类的方法

#### 依赖倒置原则

定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象，抽象不应该依赖细节

核心思想：面向接口编程，不要面向实现编程

实现：

+ 通过面向接口编程来降低类间的耦合性

#### 单一职责原则

定义：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分

作用：

+ 对象不应该承担太多职责
+ 防止冗余

实现：

+ 功能（职责）细分

#### 接口隔离原则

定义：将臃肿庞大的接口尽量拆分成更小或更具体的接口

作用：

+ 每个类的接口都要专用化
+ 降低类对接口的依赖性

#### 迪米特原则

定义：只与直接的朋友交谈，不跟陌生人说话

作用：

+ 若没有直接的联系，就不要相互调用，可通过第三方转发
+ 降低类之间的耦合度，提高模块的独立性

实现：

+ 只依赖应该依赖的对象
+ 只暴露应该暴露的接口

#### 合成复用原则

定义：在软件复用时，尽量先使用组合或者聚合关系来实现，其次才考虑继承关系实现

### 创建型模式的特点和分类

关注点：如何创建对象

特点：将对象的创建与使用分离

目的：降低系统的耦合度，使用者不必关注对象的创建细节

分类：

+ 单例
+ 原型
+ 工厂方法
+ 抽象工厂
+ 建造者



### 单例模式

在一些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只创建一个实例

#### 定义

一个类只能有一个实例，且该类能自行创建这个实例的一种模式

例如：

Windows中只能打开一个任务管理器，回收站、文件系统、线程池等等

#### 特点

+ 单例模式只有一个实例对象
+ 该单例对象必须由单例类自动创建
+ 单例类对外提供**一个**访问该单例的全局访问点

#### 结构和实现

​		一般，普通类的构造函数是公有的，外部可以通过new构造函数生成多个实例。所以，将该类的构造函数声明为私有，外部类就无法构造这个构造函数。同时，类自身必须定义一个静态私有实例，并向外提供一个静态公有函数用于创建或获取该静态私有实例

**结构：**

+ 单例类：包含一个实例且能自行创建这个实例的类
+ 访问类：使用单例对象的类

实现

**两种实现方式：**

+ 懒汉式单例

类加载时没有生成单例，只有当第一次调用 getInstance 方法时才去创建这个单例

```java
package singleton;

//懒汉式单例
public class LazySingleton {
    private static volatile LazySingleton instance = null;
    private LazySingleton() {};
    public static synchronized LazySingleton getInstance(){
        if(instance == null){
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

​	如果是多线程程序，则关键字 volatile 和 synchronized 不要删除， 否则将存在线程不安全的问题，可是如果不删除这两个关键字，每次的访问都要同步，会影响性能，且消耗更多资源，这是懒汉式单例的缺点

+ 饿汉式单例

类一旦加载就创建一个实例，保证在调用 getInstance 方法之前单例就已经存在了

```java
//饿汉式单例
public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();
    private HungrySingleton() {};
    public static HungrySingleton getInstance(){
        return instance;
    }
}
```

​		饿汉式单例在类创建的同时就已经创建好了一个静态的对象供系统使用，以后不再改变，是线程安全的，可以直接用于多线程

#### 应用场景

+ 某类只要求生成一个对象
+ 当对象需要被共享的场合。
+ 当某类需要频繁实例化，又频繁被销毁时，如多线程的线程池等

#### 扩展

​		可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在ArrayList中，需要时可随机获取。



### 原型模式

​	在一些系统中，存在着大量相同或相似对象的创建，当用构造函数创建对象时，会很复杂且耗资源，而原型模式则相对更高效

#### 定义与特点

​		用一个已经创建的实例为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象

#### 结构和特点

​		使用Java提供的clone（）对象

**结构角色：**

+ 抽象原型类：规定具体原型对象必须实现的接口
+ 具体原型类：实现抽象原型类的clone（）方法，时可被复制的对象
+ 访问类：使用具体原型类中的clone（）方法复制新对象

#### 实现

克隆分浅克隆和深克隆，Java中的Object类提供了浅克隆的clone（）方法，具体原型类只要实现Cloneable 接口就可实现对象的浅克隆，这里的Cloneable接口就是抽象原型类。

```java
public class Realizetype implements Cloneable {
    Realizetype(){
        System.out.println("具体原型创建成功");
    }
    public Object clone() throws CloneNotSupportedException {
        System.out.println("具体原型复制成功");
        return (Realizetype)super.clone();
    }
}
```

#### 应用场景

+ 对象之间相同或相似，即只有个别属性不同的时候
+ 对象的创建过程麻烦，复制简单

#### 扩展

​				可扩展为带原型管理器的原型模式，在原型模式的基础上增加了一个原型管理器PrototypeManager类，该类用HashMap保存多个复制的原型，Client类可以通过管理器的get方法获取复制的原型



### 工厂方法模式

​		软件对象的生产和使用分离

#### 定义与特点

​	定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中

​	我们把被创建的对象成为“产品”，把创建产品的对象称为“工厂”

​	如果创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”

​	工厂方法模式对其进一步抽象，可以使系统不修改原有代码的情况下引进新产品

​	满足开闭原则

优点：

+ 用户只需要直到具体工厂的名称就可以得到所要产品，无须知道产品创建过程
+ 增加新产品时只需要添加具体产品类和对应的具体工厂类，无需修改原工厂

缺点：

+ 每增加一个产品，都要添加具体产品类和对应的具体工厂类，增加系统复杂度

#### 结构和实现

结构：

+ 抽象工厂：提供创建产品的接口，调用者通过它访问具体工厂的工厂方法创建产品
+ 具体工厂：实现抽象工厂中的工厂方法，完成具体产品的创建
+ 抽象产品：定义了产品的规范，描述产品的主要特征和功能
+ 具体产品：实现抽象产品所定义的接口，由具体工厂创建

```java
    //抽象产品
    interface Product {
        public void show();
    }
    //具体产品1
    class apple implements Product {
        public void show(){
            System.out.println("生产苹果");
        }
    }
    //具体产品2
    class huawei implements Product {
        public void show(){
            System.out.println("生产华为");
        }
    }
    //抽象工厂
    interface AbstractFactory{
        public Product newProduct();
    }
    //具体工厂1，生产具体产品1
    class AppleFactory implements AbstractFactory {
        @Override
        public Product newProduct() {
            System.out.println("苹果工厂生产苹果");
            return new apple();
        }
    }
    //具体工厂2，生产具体产品2
    class HuaweiFactory implements AbstractFactory {
        @Override
        public Product newProduct() {
            System.out.println("华为工厂生产华为");
            return new huawei();
        }
    }
```

#### 应用场景

+ 客户只知道创建产品的工厂名，而不知道具体的产品名
+ 创建对象的任务由多个具体子工厂中的某一个完成
+ 客户不关心创建产品的细节



### 抽象工厂模式

​	考虑多等级产品的生产

​	将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族

#### 定义和特点

​	是一种为访问类提供一个创建一组相关或相互依赖对象的接口

​	访问类无需指定所要生产产品的具体类就可以得到同族不同等级产品的模式结构

条件：

+ 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品
+ 系统一次只能消费其中某一组的产品，即同一族产品一起使用

优点：

+ 具有工厂方法模式的优点
+ 可以在类的内部对产品族中相关联的多等级产品共同管理
+ 当增加新的产品族时，不需要修改源代码，满足开闭原则

缺点：

+ 产品族中新增产品时，所有工厂类都要修改

#### 结构和实现

结构：

+ 抽象工厂：提供创建产品的接口，包含多个创建产品的方法，可创建不同等级的产品
+ 具体工厂：实现抽象工厂中的多个抽象方法，完成具体产品的创建
+ 抽象产品：定义了产品的规范，描述产品的主要特征和功能，有多个抽象产品
+ 具体产品：实现抽象产品所定义的接口，由具体工厂创建，和具工厂之间是一对多的关系

实现：

结构同工厂模式的结构相似，不同的是其产品的种类不知一个，所以创建产品的方法也不只一个



#### 应用场景

+ 创建的对象是一些列相互关联或是相互依赖的产品族时
+ 系统中有多个产品族，但每次只使用其中的某一族产品
+ 系统中提供了产品的类库



### 建造者模式

产品由多个部分组成，各个部分可以灵活选择，但其创建的步骤都是大同小异

#### 定义和特点

​	指将一个复杂对象的构造与它的表示分离，使**同样的构建过程**可以创建不同的表示

​	将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成

优点：

+ 各个具体的建造者相互独立，利于系统扩展
+ 客户端不必知道产品内部具体组成的细节

缺点：

+ 产品的做出部分必须相同，限制了使用范围

+ 产品内部变化复杂，会增加很多的建造者类

#### 结构和实现

结构：

+ 产品角色：包含多个组成部件的复杂对象
+ 抽象建造者：包含创建产品各个子部件的抽象方法的接口，包含一个返回复杂产品的方法
+ 具体建造者：实现抽象建造者接口，完成各个不及按的具体创建方法
+ 指挥者：调用建造者对象中的部件构造与装配方法完成复杂对象的创建

实现：

```java

```

#### 应用场景

+ 创建的对象较复杂，由多个部件构成
+ 产品的构建过程和最终表示时独立的



## 结构型模式的特点和分类

​	描述如何将类或对象按某种布局组成更大的结构

​	由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构模型比类结构模型更灵活

### 代理模式 Proxy

​	一个客户不能或不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务

生活中的实例：

+ 腾讯代理游戏
+ 应用商店代理游戏
+ 中介
+ 婚介


#### 定义和特点

​	由于某些原因需要给某个对象提供一个代理以控制对该对象的访问

​	当访问对象不适合或不能直接引用对象，代理对象作为访问对象和目标对象之间的中介

优点：

+ 保护目标对象
+ 可扩展目标对象的功能
+ 降低系统耦合度

缺点：

+ 请求处理速度变慢
+ 增加系统复杂度

#### 结构和实现

结构：

+ 抽象主题类：通过接口或抽象类声明真实主题
+ 真实主题类：实现抽象主题中的具体业务
+ 代理类：提供了与真实主题相同的接口

实现：

```java
    interface Subject {
        void Request();
    }
    //真实角色
    class RealSubject implements Subject{
        public void Request() {
            System.out.println("访问真实主题的方法");
        }
    }
    //代理角色
    class ProxySubject implements Subject{
        //代理的真实角色
        private RealSubject realSubject;
        public void Request() {
            if(realSubject == null){
                realSubject = new RealSubject();
            }
            preRequest();
            realSubject.Request();
            postRequest();
        }
        public void preRequest() {
            System.out.println("代理前做的事");
        }
        public void postRequest() {
            System.out.println("代理后做的事");
        }
    }
```

#### 应用场景

实现远程代理

实现虚拟代理

实现安全代理

实现延迟加载

#### 代理模式的分类：

+ 静态代理
+ 动态代理

#### 静态代理

角色分析：

+ 抽象角色：一般会使用接口或抽象类来实现
+ 真实角色：被代理的角色
+ 代理角色：代理真实角色，代理后，一般会实现一些附加操作
+ 客户：访问代理对象的人

#### 动态代理

![image-20200721140738330](D:/Photo/Typora/image-20200721140738330.png)



### 适配器模式（Adapter）

**意图**

+ 把一个类接口转换成另一个用户需要的接口。适配器模式让那些接口不兼容的类可以一起工作

**类型**

+ 既可以作为类结构型模式，也可以作为对象结构型模式
+ 对象适配器：（传入对象）组合方式，推荐使用这种方式
+ 类适配器：（多重继承）继承方式，效率更高

**实现**

鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack（）方法，而Turkey 调用的是 gobble（）方法，要求将Turkey 的 gobble（）方法适配成 Duck 的 quack（）方法

```java
public interface Duck{	void quack();	}
public interface Turkey{	void gobble();	}
public class WildTurkey implements Turkey{
    @Override
    public void gobble() {
        System.out.println("gobble!");
    }
}
public class TurkeyAdapter implements Duck{
    Turkey turkey;
    public TarkeyAdapter(Turkey turkey) {	this.turkey = turkey;	}
    @Override
    public void quack(){
        //调用的是Duck的quack方法，具体实现的却是Turkey的gobble方法
        turkey.gobble();
    }
}
public class Client {
    public static void main(String[] args){
        Turkey turkey = new WildTurkey();
        Duck duck = new TurkeyAdapter(turkey);
        duck.quack();
    }
}
```

### 桥接模式

### 装饰模式

### 外观模式

### 享元模式

### 组合模式

## 行为型模式的特点和分类

### 模板方法模式

### 策略模式

当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该任务，如数据排序策略有冒泡排序、选择排序、插入排序等

如果使用多重条件转移语句实现（即硬编码），不但使条件语句变复杂，而且增加、删除或更换算法要修改源代码，不易维护，采用策略模式来解决该问题

**意图**

+ 定义一系列的算法，分装每个算法，并使得它们可以互换
+ 策略模式可以让算法独立于使用它的客户端

**类图**

+ Strategy 接口定义了一个算法族，它们都具有 behavior（）方法
+ Context 是使用到该算法族的类，其中的doSomething（）方法会调用 behavior（），setStrategy（in Strategy）方法可以动态改变 strategy 对象，即动态改变Context所使用的算法

**实现**

设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为

```java
public interface QuackBehavior{
    void quack();
}
public class Quack implements QuackBehavior{
    @Override
    public void quack(){
        System.out.println("quack!");
    }
}
public class Squeak implements QuackBehavior{
    @Override
    public void quack(){
        System.out.println("squeak!");
    }
}
public class Duck{
    private QuackBehavior quackBehavior;
    //实现其中的quack方法
    public void performQuack(){
        if(quackBehavior != null)
            quackBehavior.quack();
    }
    //设置哪种叫声
    public void setQuackBehavior(QuackBehavior quackBehavior){
        this.quackBehavior = quackBehavior;
    }
}
puublic class Client {
    public static void main(String[] args){
        Duck duck = new Duck();
        duck.setQuackBehavior(new Quack());
        duck.performQuack();
        duck.setQuackBehavior(new Squeak());
        duck.performQuack();
    }
}
```

### 命令模式

### 责任链模式、







### 状态模式

不使用状态模式进行状态转换时的缺点：

+ 需要进行大量的switch-case判断，可阅读型很差
+ 扩展性很差，如果要增加一个状态，就需要对判断逻辑进行整体的修改



定义：

状态模式（State Pattern），用来解决对象在多种状态之间转换时，需要对外输出不同心态的问题，状态是和行为一一对应的，状态可以相互转化，可以把复杂的判断逻辑转换到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为



主要角色：

+ 环境角色：也称为上下文，定义客户程序所需要的接口，维护一个当前状态
+ 抽象状态角色：定义一个接口，用于封装环境对象中特定状态所对应的行为
+ 具体状态角色：事项抽象状态所对应的行为



当对象内在状态改变了，则说明其行为也改变了，对象像是改变了其类


### 观察者模式

### 中介者模式

### 迭代器模式

### 访问者模式

### 备忘录模式

### 解释器模式

