## Python

- 适合脚本处理
- 简单易用
- 支持全平台
- 模块化
- 解释型语言
- 使用缩进
- 可扩展

### 解释器

Python 的执行环境，各个操作系统都可以安装
可以执行python文件或者使用交互模式
进入交互模式命令：`python`
退出交互模式命令：`exit()`

### 速览

注释：`#`开头，直到该物理行结束

数字运算符：
- +、- 表示加减运算
- / 表示普通除，结果为浮点数
- // 表示整除，结果向下取整
- * 表示乘法
- ** 幂运算符
- % 表示取模运算符，即获取余数
- = 赋值

字符串：
- '' 或 "" 标注
- \ 用于转义
- 三重引号：'''xx''' 或 """xx""" 可以实现多行
- 用 + 合并，用 * 重复
- 字符串支持下标访问，并支持负数（从右往左计数）
- 支持切片，切片提取子字符串，如：`[0:2]`
- 不能修改的，为字符串中的某个索引位置赋值会报错
- `len()` 内置函数返回字符串长度

列表：

- 方括号标注，逗号分隔：[1, 2, 3]
- 列表可以包含不同类型的元素，一般情况下，类型相同
- 支持索引和切片（切片会返回列表的浅拷贝）
- 支持使用 + 合并
- 内容可该表，即使用索引改变里面的某个下标的值
- 为切片赋值可以改变列表大小
- `len()` 内置函数返回嵌套长度
- 列表可以嵌套

### 流程控制

if 语句

判断
`if`
`elif`
`else`
在交互模式中需要使用`:`

for 语句

循环
`for x in xList:`

注意：遍历集合修改集合内容容易造成错误结果，应该便利集合副本（copy()）或创建新集合

range() 函数

用于遍历数字序列，可以生成算数级数，例如：
`range(5)` '[0, 1, 2, 3, 4]'
`range(5, 10)` '[5, 6, 7, 8, 9]'
`range(0, 10, 3)` '[0, 3, 6, 9]'

range() 迭代时基于所需序列返回连续项，并没有生成真实的列表，这种对象称为可迭代对象 `iterrable`

break、continue、else 子句

- break
  - 跳出 for 或 while 循环
- else
  - 作用于循环语句，当循环全部循环完毕
  - while 循环的条件为假时，执行该子句
  - *break终止循环时，不执行*
- continue
  - 继续执行循环的下一次迭代

pass 语句

- 不执行任何操作
- 语法上需要一个语句，但程序实际不执行任何动作
- 用作函数或条件子句的占位符

match 语句

- 模式匹配，类似于 switch
- 仅执行第一个匹配的模式
- 可以将值提取到变量中

```
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404 | 401 | 403:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Something's wrong with the internet"
```

- '_' 被作为通配符必定会匹配成功
- '|' 可以组合多个字面值
- 可以解包赋值，并被用于绑定变量


*有一些难理解的知识点，后续再看下*

### 函数

定义

```
>>> def fib(n):
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while a < n:
...             print(a, end= ' ')
...             a, b = b, a + b
...     print()
...
>>> fib(100)
```

- `def` 关键字
- 后面跟函数名与括号内的形参列表
- 函数语句从下一行开始，并且必须缩进
- 函数内的第一条语句是字符串时，该字符串就是文档字符串（docstring），用于在线文档生成
- 函数变量查找顺序：局部符号表 -> 外层符号表 -> 全局符号表 -> 内置符号表
- 调用函数时会将实际参数引入到函数的局部符号表中（实参是*按值调用*传递，即对象是引用）
- `return` 语句返回函数的值，不带表达式参数时，返回 `None` 

参数值

1. 默认值参数
`def ask_ok(prompt, retries=4, reminder='Please try again!'):`
这样在传参时后两个可传可不传，不传使用默认值
默认值在 *定义* 作用域里的函数定义中求值
默认值只计算一次，当默认值为列表、字典或类实例等可变对象时，会产生不同结果

2. 关键字参数
`def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):`
`kwarg=value` 形式的 关键字参数 也可用于调用函数
调用方式：`parrot(voltage=1000000, action='VOOOOOM') `
所有传递的关键字参数都必须匹配一个函数接受的参数
非有序性
不能对同一个参数多次赋值
形参为`**name`形式，接收一个字典， 包含与函数中已定义形参对应之外的所有关键词参数
形参为`*name`形式，接收一个元组，包含形参列表之外的位置参数

3. 特殊参数
默认情况下，参数可以按照位置或显示关键字传递给Python函数
为确定参数项是仅按位置、按位置或关键字、仅按关键字传递，函数定义如下：
`def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):`
'/'  和 '*' 可选

- 位置或关键字参数
  - 未使用 / 和 * 时，位置或关键字传递都可以
  - / 表示其之前的形参都是位置参数，其顺序很重要
  - '*' 标识其之后的形参都是关键字参数
  - / 之后 和 '*' 之前的参数两者都可

Lambda 表达式

用于创建小巧的匿名函数
`lambda a, b: a+b` 函数返回两个参数的和

文档字符串

- 第一行应为对对象用途的简短摘要
- 大写字母开头，句点结尾
- 多行时，第二行为空白行，后面的行可包含若干段落
- 查看：fun_name.`__doc__`

```
>>> def my_function():
...     """
...     Do nothing, but document it.
...
...     No, really, it doesn't do anything.
...     """
...     pass
```

编码风格

- 缩进，用 4 个空格，不要用 制表符
- 换行，一行不要超过 79 个字符
- 用空行分隔函数和类，以及函数内较大的代码块
- 注释尽量单独一行
- 使用文档字符串
- 运算符前后使用空格
- ...

### 数据结构

列表

list 方法
- list.append(x)
- list.extend(iterable)
- list.insert(i, x)
- list.remove(x)
- list.pop([i])
- list.clear()
- list.index(x[, start[, end]])
- list.count(x)
- list.sort(*, key=None, reverse=False)
- list.reverse()
- list.copy()

list 应用

- 有序数组
- 栈
- 队列（慢，插入头时）
  
列表推导式

对序列或可迭代对象的每个元素应用某种操作，用生成的结果创建新的列表
用满足特定条件的元素创建子序列

1. 基础
`squares = [x**2 for x in range(20)]`
其中变量x会被创建和覆盖，循环结束后仍然存在

2. 嵌套
`[[row[i] for row in matrix] for i in range(4)]`

del

1. 按索引或切片删除列表元素 `del a[0]` `del a[2:4]`
2. 可以清空整个列表 `del a[:]`
3. 删除变量（之后再引用会报错） `del a`

元组和序列

元组：
- 标准序列类型（序列类型：list：列表、tuple：元组、range：值域）
- 元组由多个用逗号隔开的值组成
- 输出时，元组由圆括号标注，用以解释嵌套元组
- 不允许为元组的单个元素赋值，但可以创建含列表等可变对象的元组
- 元组是 immutable（不可变的），一般可包含异质元素序列，通过解包或索引访问
- 列表是 nutable（可变的），列表元素一般为同质类型，可迭代访问
- 0个元素的元组使用一对()创建，一个元素的元组通过加逗号来构建
- 元组可以进行打包（下面的t），也可以进行序列解包，如`x, y, z = t`
```
>>> t = 12345, 543, 'hello'
>>> t[0]
12345
>>> t
(12345, 543, 'hello')
>>>
>>> t[0] = 123
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> u = t, (1, 2, 3)
>>> u
((12345, 543, 'hello'), (1, 2, 3))
```

集合

- 由不重复元素组成的无序容器
- 基本方法包括成员检测、消除重复元素
- 支持合集、交集、差集等数学计算
- 创建集合使用花括号或`set()`函数
- 创建空集合只能用`set()`，不能用 `{}`，`{}`创建的是空字典
- 支持 列表推导式

```
>>> basket = {'a', 'b', 'c', 'd'}
>>> basket
{'a', 'b', 'd', 'c'}
>>> a in basket
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
>>> 'a' in basket
True
>>> 'e' in basket
False
>>>
>>> a = set('abcd'
... )
>>> b = set('cdef')
>>> a - b  # 只属于a的
{'a', 'b'}
>>> a | b  # 并集
{'f', 'e', 'a', 'b', 'c', 'd'}
>>> a & b  # 交集
{'c', 'd'}
>>> a ^ b  # 差集
{'e', 'a', 'b', 'f'}
```

字典

- 映射类型 - dict
- 以 *关键字* 为索引，关键字通常为字符或数字（或其他任何不可变类型）
- 元组作为关键字时不能直接或间接包含可变对象；列表不能当关键字
- *键值对* 的集合，键必须唯一，`{}`用于创建空字典，或花括号里输入逗号分隔的键值对
- 用途：通过关键字存储、提取值，`del` 可以删除键值对

```
>>> tel = {'jack' : 4098, 'sape' : 4139}
>>> tel
{'jack': 4098, 'sape': 4139}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'irv': 4127}
>>> list(tel)
['jack', 'irv']
>>> tel['guido'] = 4128
>>> sorted(tel)
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' in tel
True
>>>
>>> dictTemp = dict([('sape', 3333), ('jack', 5555)]) # 用dict()构造函数创建字典
>>> dictTemp
{'sape': 3333, 'jack': 5555}
```

循环的技巧

1. 用 items() 方法可以同时提取出字典的键和值
`for k, v in knights.items():`

2. 序列循环中，用 `enumerate()` 可以同时取出索引位置和值
`for i, v in enumerate(['tic', 'tac', 'toe']):`

3. 同时循环多个序列时，用 `zip()` 函数将元素一一匹配

4. 逆向循环序列时，先正向定位序列，然后用 `reversed()` 函数

5. 用 `sorted()` 函数可以在不改动原有序列的基础上排序生成新的序列

6. `set()` 可以去除序列中的重复元素

### 模块

1. Python 编辑器定义的函数和变量在退出重进后会丢失
2. 编写长程序建议使用文本编辑器，即执行脚本文件
3. 拆分多个文件，并且在函数调用时不用复制到各处去

为满足上述需求，Python 将各种定义存入到一个文件，在脚本或解释器的交互式实例中使用，这个文件就是模块

模块中的定于可以导入到其他模块或主模块

模块是包含 Python 定义和语句的文件，文件名是模块名加后缀名 `.py`
模块内部，通过全局变量 `__name__` 可以获取模块名（字符串）

### 输入与输出

- 格式化字符串字面量

在字符串开头的引号/三引号前添加 `f` 或 `F`，在这种字符串中，可以在`{}`引入变量或 python 表达式

- `str.format()` 方法

可以用 `{}` 标记替换变量位置，并且支持详细的格式化指令


### 错误和异常

句法错误

又称解析错误，常见的错误
解析器会浮现出现句法错误的代码行，并用小箭头只想检测到的第一个错误
会输出文件名和行号

异常

执行时检测到的错误成为异常
大多数异常不会被程序处理，而是显示错误信息

异常被捕获后，会显示具体异常的类型以及文件名和行数

异常包括内置异常和用户自定义异常
- 内置异常即Python自带内置的一些异常
  - ZeroDivisionError
  - NameError
  - TypeError
- 自定义异常是用户自己定义出来的异常

异常处理

使用 try except 语句

```
while True:
      try:
            x = int(input("Please enter a number: "))
            break
      except ValueError:
            print("Try again...")
```

如果发生的异常与 except 子句中指定的异常不匹配，则会被传递到外面的try语句；没有找到处理程序的化，则属于是未处理异常并直接被抛出

try 语句可以有多个 except 子句来为不同的异常指定处理程序，但最多只有一个处理程序被执行
如果发生的异常与 except 子句中的类是同一个类或是其基类时，相互兼容
```
except (RuntimeError, TypeError, NameError):

except D:
        print("D")
    except C:
        print("C")
    except B:
        print("B")
```

try ... except 语句具有可选的 else 子句，该子句存在，则必须放到 except 子句之后，它适用于 try 子句没有引发异常但又必须要执行的代码（像是关闭文件等操作）

触发异常

`raise` 语句支持强制出发指定异常
`raise NameError('xx')`

异常链

如果未处理的异常发生在 except 部分内，则会附加正在处理的异常并包含在错误消息中

自定义异常

程序可以通过创建新的异常类命名自己的异常，不论时直接还是间接的方式，异常都应该从 `Exception` 类派生

定义清理操作

`finally` 子句位于 try 之后，可以定义为在所有情况下都必须要执行的清理操作

- 如果执行 try 子句期间触发了某个异常，则某个 except 子句应处理该异常。
- 如果该异常没有 except 子句处理，在 finally 子句执行后会被重新触发。
- except 或 else 子句执行期间也会触发异常。 同样，该异常会在 finally 子句执行之后被重新触发。
- 如果 finally 子句中包含 break、continue 或 return 等语句，异常将不会被重新引发。
- 如果执行 try 语句时遇到 break,、continue 或 return 语句，则 finally 子句在执行 break、continue 或 return 语句之前执行。
- 如果 finally 子句中包含 return 语句，则返回值来自 finally 子句的某个 return 语句的返回值，而不是来自 try 子句的 return 语句的返回值。

finally 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源

预定义的清理操作

某些对象定义了不需要该对象时要执行的标准清理操作。无论对象操作是否成功，都会执行清理操作。
`with` 语句支持及时、正确的清理方式使用文件对象

`with open("myfile.txt") as f:`



### 类

- 类把数据和功能绑定到一起
- 创建类就是创建新的对象类型，从而创建该类型的新实例
- 类支持维持自身状态的属性，并支持修改自身状态的方法
- 支持继承、派生、调用基类同名方法，可包含任意数量和类型的数据

名称和对象

- 对象之间相互独立，多个名称（在多个作用域内）可以绑定到同一个对象（引用）

作用域和命名空间


`namespace` （命名空间）是映射到对象的名称
- 使用字典实现
- 常见实例
  - abs() 函数
  - 内置异常函数
  - 模块中的全局名称
  - 函数调用中的局部名称
  - 对象的属性集合

点号（.）之后的名称是属性
- 属性可以只读或可写，如果可写，则可对属性赋值
- del 语句可以删除可写属性
  
命名空间在不同时刻创建，且拥有不同的生命周期
内置名称的命名空间在 Python 启动器启动时创建的，永远不会被删除
模块的全局命名空间是在读取模块定义时创建
函数的本地命名空间在调用该函数时创建，并在返回或抛出异常时删除

作用域是命名空间可直接访问的 Python 程序的文本区域
'可直接访问' 代表着对名称的非限定引用会在命名空间中查找名称
静态确认，动态使用
作用域规则：
- 最内层作用域，包含局部名称，首先搜索
- 倒数第二个作用域，包含当前模块的全局名称
- 最外层的作用域，包含内置名称的命名空间，最后搜索

通常，当前局部作用域将引用当前函数的局部名称
global 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定
nonlocal 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。

类

定义
```
class ClassName:
    <statement-1>
    .
    <statement-N>
```
与函数定义（def 语句）一样，类定义必须先执行才能生效
当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域
当离开类定义时，将创建一个 类对象

Class 对象

类支持两种操作：属性引用和实例化

属性引用：`obj.name`
实例化：`x = MyClass()`

实例化对象

- 属性引用
  - 数据属性
  - 方法

数据属性不需要声明，将在第一次被赋值时产生
方法属性时从属于对象的函数